üöÄ Fluxo Completo de uma API em .NET (Explicado)

=========================================
1. MODELS
=========================================
- S√£o classes que representam as ENTIDADES do sistema.
- Cada Model normalmente corresponde a uma tabela no banco de dados.
- Exemplo: User, Product, Order.

=========================================
2. DBCONTEXT
=========================================
- Classe que herda de DbContext (do Entity Framework Core).
- Respons√°vel por mapear Models ‚Üî Banco de Dados.
- √â nele que configuramos as tabelas (DbSet<User>, DbSet<Product>, etc).
- Registrado como servi√ßo no Program.cs.

=========================================
3. MIGRATIONS
=========================================
- Permitem criar e atualizar o schema do banco a partir dos Models.
- S√£o uma forma de versionar o banco de dados.
- Comandos principais:
  dotnet ef migrations add InitialModel
  dotnet ef database update

=========================================
4. SERVICES e USECASES
=========================================
- SERVICES:
  - Interfaces (ex.: IUserService) ‚Üí contratos.
  - Implementa√ß√µes (ex.: UserService) ‚Üí c√≥digo que executa as regras.
- USECASES:
  - Organiza√ß√£o da l√≥gica de neg√≥cio.
  - Cada UseCase representa uma a√ß√£o que o usu√°rio pode fazer.
  - S√£o equivalentes aos Endpoints, mas organizados em classes pr√≥prias.
  - Exemplo: CreateUserUseCase, LoginUseCase.

=========================================
5. CONTROLLERS + ENDPOINTS
=========================================
- Controllers s√£o classes que recebem requisi√ß√µes HTTP (GET, POST, PUT, DELETE).
- Cont√™m os ENDPOINTS da API.
- Fun√ß√£o principal: receber o payload da requisi√ß√£o ‚Üí chamar o UseCase ‚Üí devolver a resposta.

=========================================
6. PAYLOADS & RESPONSES
=========================================
- PAYLOAD: √© o que o cliente envia para a API (ex.: JSON de cadastro de usu√°rio).
- RESPONSE: √© o que a API retorna para o cliente (padr√£o de resposta).

=========================================
7. CONFIGURA√á√ÉO DE SERVI√áOS (DI - Dependency Injection)
=========================================
No Program.cs registramos servi√ßos com diferentes ciclos de vida:

- Singleton ‚Üí mesmo objeto para toda a aplica√ß√£o.
  Exemplo: servi√ßo de configura√ß√£o global.
- Scoped ‚Üí objeto criado por requisi√ß√£o (vive enquanto a requisi√ß√£o existir).
  Exemplo: DbContext.
- Transient ‚Üí novo objeto a cada chamada.
  Exemplo: servi√ßos pequenos e n√£o compartilh√°veis (ex.: LoginService).

=========================================
8. TESTES
=========================================
- Usamos pacotes como xUnit, Moq e Microsoft.NET.Test.Sdk.
- Garantem que os UseCases e Services funcionem corretamente.

=========================================
9. SWAGGER
=========================================
- Pacote: Swashbuckle.AspNetCore
- Gera documenta√ß√£o interativa da API automaticamente.

=========================================
üõ†Ô∏è SETUP INICIAL
=========================================
dotnet new web
dotnet new gitignore

dotnet add package Microsoft.EntityFrameworkCore
dotnet add package Microsoft.EntityFrameworkCore.Tools
dotnet add package Microsoft.EntityFrameworkCore.Design
dotnet add package Microsoft.EntityFrameworkCore.SqlServer

$env:SQL_CONNECTION = "Data Source=localhost;Initial Catalog=Fofoquinha;Trust Server Certificate=true;Integrated Security=true"

dotnet tool install --global dotnet-ef
dotnet ef migrations add InitialModel
dotnet ef database update

dotnet add package xunit
dotnet add package xunit.runner.visualstudio
dotnet add package Microsoft.NET.Test.Sdk
dotnet add package Moq

dotnet add package Swashbuckle.AspNetCore

=========================================
‚úÖ PASSO A PASSO RESUMIDO
=========================================
01. Criar Models
02. Criar DbContext
03. Configurar conex√£o com SQL (vari√°vel de ambiente)
04. Criar e rodar Migrations
05. Criar classe Result (para padronizar retorno)
06. Definir UseCases (sem implementar)
07. Definir Payloads e Responses
08. Criar Controller com Endpoints
09. Implementar UseCases (regras de neg√≥cio)
10. Injetar UseCases como servi√ßos (DI)
11. Implementar Servi√ßos auxiliares (ex.: AuthService)
12. Criar e rodar Testes
13. Configurar Swagger

=========================================
üîë CONCLUS√ÉO
=========================================
Esse √© o fluxo padr√£o de uma API organizada em .NET com boas pr√°ticas:
- Models ‚Üí representam os dados
- DbContext ‚Üí conecta com o banco
- Migrations ‚Üí versionam o banco
- UseCases ‚Üí organizam a l√≥gica
- Controllers/Endpoints ‚Üí exp√µem a API
- Services ‚Üí abstraem funcionalidades
- Payloads/Responses ‚Üí padronizam comunica√ß√£o
- Testes ‚Üí garantem qualidade
- Swagger ‚Üí documenta a API
